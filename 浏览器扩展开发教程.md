# 浏览器扩展开发教程

## 目录
- [浏览器扩展架构概述](#浏览器扩展架构概述)
- [核心组成部分](#核心组成部分)
  - [1. Manifest 文件](#1-manifest-文件)
  - [2. Background Scripts (Service Worker)](#2-background-scripts-service-worker)
  - [3. Content Scripts](#3-content-scripts)
  - [4. Popup 界面](#4-popup-界面)
  - [5. Options 页面](#5-options-页面)
  - [6. Side Panel (侧边栏)](#6-side-panel-侧边栏)
  - [7. DevTools Panel (开发者工具面板)](#7-devtools-panel-开发者工具面板)
  - [8. Context Menu (右键菜单)](#8-context-menu-右键菜单)
  - [9. Omnibox (地址栏集成)](#9-omnibox-地址栏集成)
  - [10. Override Pages (覆盖页面)](#10-override-pages-覆盖页面)
- [核心 API](#核心-api)
- [权限系统](#权限系统)
- [开发工作流程](#开发工作流程)
- [关键概念](#关键概念)
- [学习路径建议](#学习路径建议)

---

## 浏览器扩展架构概述

浏览器扩展是一种软件插件，用于增强和定制浏览器的功能。不同浏览器有各自的扩展系统：

- **Chrome/Edge**: Chrome Extension API (Manifest V3)
- **Firefox**: WebExtensions API
- **Safari**: Safari Web Extensions

### 完整架构图
```
浏览器扩展
├── 用户界面层
│   ├── Popup (弹出界面)
│   ├── Side Panel (侧边栏)
│   ├── Options Page (设置页面)
│   ├── DevTools Panel (开发工具面板)
│   └── Override Pages (覆盖页面)
├── 内容交互层
│   ├── Content Scripts (内容脚本)
│   └── Context Menu (右键菜单)
├── 逻辑处理层
│   ├── Background/Service Worker (后台服务)
│   └── Omnibox (地址栏集成)
└── 数据存储层
    ├── Storage API
    ├── IndexedDB
    └── Chrome Storage
```

---

## 核心组成部分

### 1. Manifest 文件
扩展的配置文件，定义了扩展的基本信息和权限。

**Manifest V3 示例:**
```json
{
  "manifest_version": 3,
  "name": "我的扩展",
  "version": "1.0.0",
  "description": "扩展描述",
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "permissions": ["storage", "tabs", "sidePanel"],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png"
    }
  },
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"],
    "css": ["content.css"]
  }],
  "options_page": "options.html",
  "side_panel": {
    "default_path": "sidepanel.html"
  },
  "devtools_page": "devtools.html"
}
```

### 2. Background Scripts (Service Worker)
在后台运行的脚本，负责：
- 监听浏览器事件
- 管理扩展状态
- 处理跨页面逻辑
- 作为扩展的"大脑"协调各组件

```javascript
// background.js
chrome.runtime.onInstalled.addListener(() => {
  console.log('扩展已安装');

  // 初始化设置
  chrome.storage.local.set({
    settings: {
      theme: 'light',
      notifications: true
    }
  });
});

// 监听扩展图标点击
chrome.action.onClicked.addListener((tab) => {
  chrome.tabs.create({ url: 'https://example.com' });
});

// 监听消息
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getData') {
    sendResponse({ data: 'some data' });
  }
  return true; // 保持消息通道开启
});

// 监听标签页更新
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete' && tab.url) {
    console.log('页面加载完成:', tab.url);
  }
});
```

### 3. Content Scripts
注入到网页中的脚本，可以：
- 访问和修改DOM
- 与页面JavaScript交互
- 与background script通信
- 拦截网络请求

```javascript
// content.js
// 修改页面内容
document.body.style.backgroundColor = '#f0f0f0';

// 创建新元素
const widget = document.createElement('div');
widget.id = 'my-extension-widget';
widget.innerHTML = '<p>Hello from extension!</p>';
document.body.appendChild(widget);

// 监听来自background的消息
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getPageInfo') {
    sendResponse({
      title: document.title,
      url: window.location.href,
      content: document.body.innerText.substring(0, 100)
    });
  }
  return true;
});

// 监听页面事件
window.addEventListener('scroll', () => {
  chrome.runtime.sendMessage({
    action: 'scrollUpdate',
    scrollTop: window.pageYOffset
  });
});

// 与页面脚本通信
window.postMessage({
  type: 'FROM_EXTENSION',
  data: 'Hello from content script'
}, '*');

// 拦截特定请求
const originalFetch = window.fetch;
window.fetch = function(...args) {
  console.log('Extension intercepted fetch:', args);
  return originalFetch.apply(this, args);
};
```

### 4. Popup 界面
用户点击扩展图标时显示的界面。

**HTML:**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="popup.css">
</head>
<body>
  <div class="container">
    <h1>我的扩展</h1>
    <div class="status">状态: <span id="statusText">就绪</span></div>
    <button id="actionBtn">执行操作</button>
    <button id="settingsBtn">设置</button>
  </div>
  <script src="popup.js"></script>
</body>
</html>
```

**CSS:**
```css
/* popup.css */
body {
  width: 300px;
  padding: 15px;
  font-family: Arial, sans-serif;
}

.container {
  text-align: center;
}

h1 {
  font-size: 18px;
  margin-bottom: 15px;
}

.status {
  margin: 10px 0;
  padding: 8px;
  background: #f0f0f0;
  border-radius: 4px;
}

button {
  width: 100%;
  padding: 10px;
  margin: 5px 0;
  border: none;
  border-radius: 4px;
  background: #4285f4;
  color: white;
  cursor: pointer;
}

button:hover {
  background: #3367d6;
}
```

**JavaScript:**
```javascript
// popup.js
document.addEventListener('DOMContentLoaded', () => {
  const actionBtn = document.getElementById('actionBtn');
  const settingsBtn = document.getElementById('settingsBtn');
  const statusText = document.getElementById('statusText');

  // 获取当前标签页信息
  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
    statusText.textContent = `当前页面: ${tabs[0].title}`;
  });

  // 执行操作
  actionBtn.addEventListener('click', async () => {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

    // 发送消息到content script
    chrome.tabs.sendMessage(tab.id, { action: 'hello' }, (response) => {
      if (response) {
        statusText.textContent = '操作完成!';
      }
    });

    // 或者注入脚本
    chrome.scripting.executeScript({
      target: { tabId: tab.id },
      func: () => {
        alert('Hello from extension!');
      }
    });
  });

  // 打开设置页面
  settingsBtn.addEventListener('click', () => {
    chrome.runtime.openOptionsPage();
  });
});
```

### 5. Options 页面
扩展的设置页面，用于配置用户偏好。

**manifest.json 配置:**
```json
{
  "options_page": "options.html",
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  }
}
```

**HTML:**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="options.css">
</head>
<body>
  <div class="options-container">
    <h1>扩展设置</h1>

    <div class="setting-group">
      <h2>外观设置</h2>
      <label>
        <input type="radio" name="theme" value="light" checked>
        浅色主题
      </label>
      <label>
        <input type="radio" name="theme" value="dark">
        深色主题
      </label>
    </div>

    <div class="setting-group">
      <h2>功能设置</h2>
      <label>
        <input type="checkbox" id="notifications" checked>
        启用通知
      </label>
      <label>
        <input type="checkbox" id="autoSave">
        自动保存
      </label>
    </div>

    <div class="setting-group">
      <h2>高级设置</h2>
      <label>
        API Key:
        <input type="text" id="apiKey" placeholder="输入API Key">
      </label>
    </div>

    <div class="buttons">
      <button id="saveBtn">保存设置</button>
      <button id="resetBtn">重置默认</button>
    </div>
  </div>

  <div id="statusMessage"></div>
  <script src="options.js"></script>
</body>
</html>
```

**JavaScript:**
```javascript
// options.js
document.addEventListener('DOMContentLoaded', () => {
  // 加载保存的设置
  chrome.storage.local.get(['settings'], (result) => {
    const settings = result.settings || {
      theme: 'light',
      notifications: true,
      autoSave: false,
      apiKey: ''
    };

    // 应用设置到界面
    document.querySelector(`input[name="theme"][value="${settings.theme}"]`).checked = true;
    document.getElementById('notifications').checked = settings.notifications;
    document.getElementById('autoSave').checked = settings.autoSave;
    document.getElementById('apiKey').value = settings.apiKey;
  });

  // 保存设置
  document.getElementById('saveBtn').addEventListener('click', () => {
    const settings = {
      theme: document.querySelector('input[name="theme"]:checked').value,
      notifications: document.getElementById('notifications').checked,
      autoSave: document.getElementById('autoSave').checked,
      apiKey: document.getElementById('apiKey').value
    };

    chrome.storage.local.set({ settings }, () => {
      showMessage('设置已保存!', 'success');
    });
  });

  // 重置设置
  document.getElementById('resetBtn').addEventListener('click', () => {
    const defaultSettings = {
      theme: 'light',
      notifications: true,
      autoSave: false,
      apiKey: ''
    };

    chrome.storage.local.set({ settings: defaultSettings }, () => {
      // 重新加载页面
      location.reload();
    });
  });

  function showMessage(message, type) {
    const statusDiv = document.getElementById('statusMessage');
    statusDiv.textContent = message;
    statusDiv.className = `message ${type}`;
    setTimeout(() => {
      statusDiv.textContent = '';
      statusDiv.className = '';
    }, 3000);
  }
});
```

### 6. Side Panel (侧边栏)
提供一个持久的侧边栏界面，用户可以随时访问。

**manifest.json 配置:**
```json
{
  "permissions": ["sidePanel"],
  "side_panel": {
    "default_path": "sidepanel.html"
  }
}
```

**HTML:**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="sidepanel.css">
</head>
<body>
  <div class="sidepanel-container">
    <h2>侧边栏</h2>
    <div id="content">
      <p>这是一个持久显示的侧边栏</p>
    </div>
    <div class="controls">
      <button id="refreshBtn">刷新内容</button>
      <button id="clearBtn">清除历史</button>
    </div>
  </div>
  <script src="sidepanel.js"></script>
</body>
</html>
```

**JavaScript:**
```javascript
// sidepanel.js
// 从background获取数据
chrome.runtime.sendMessage({ action: 'getSidePanelData' }, (response) => {
  if (response && response.data) {
    displayData(response.data);
  }
});

// 监听background的更新
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'updateSidePanel') {
    displayData(request.data);
  }
});

document.getElementById('refreshBtn').addEventListener('click', () => {
  chrome.runtime.sendMessage({ action: 'refreshData' });
});

function displayData(data) {
  const contentDiv = document.getElementById('content');
  contentDiv.innerHTML = '';

  data.forEach(item => {
    const itemDiv = document.createElement('div');
    itemDiv.className = 'data-item';
    itemDiv.textContent = item.title || item.text;
    contentDiv.appendChild(itemDiv);
  });
}
```

### 7. DevTools Panel (开发者工具面板)
在Chrome DevTools中添加自定义面板。

**manifest.json 配置:**
```json
{
  "devtools_page": "devtools.html"
}
```

**devtools.html:**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
</head>
<body>
  <script src="devtools.js"></script>
</body>
</html>
```

**devtools.js:**
```javascript
// devtools.js
// 创建DevTools面板
chrome.devtools.panels.create(
  'My Panel',
  'icons/icon16.png',
  'panel.html',
  (panel) => {
    // 面板显示时
    panel.onShown.addListener((window) => {
      console.log('Panel shown');
    });

    // 面板隐藏时
    panel.onHidden.addListener(() => {
      console.log('Panel hidden');
    });
  }
);

// 创建侧边栏
chrome.devtools.panels.elements.createSidebarPane(
  'My Sidebar',
  (sidebar) => {
    sidebar.setPage('sidebar.html');
  }
);
```

**panel.html:**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="panel.css">
</head>
<body>
  <h1>DevTools 面板</h1>
  <div id="output"></div>
  <script src="panel.js"></script>
</body>
</html>
```

### 8. Context Menu (右键菜单)
为网页添加自定义右键菜单项。

**manifest.json 配置:**
```json
{
  "permissions": ["contextMenus"],
  "background": {
    "service_worker": "background.js"
  }
}
```

**background.js:**
```javascript
// 创建右键菜单
chrome.runtime.onInstalled.addListener(() => {
  // 简单菜单项
  chrome.contextMenus.create({
    id: 'myMenu',
    title: '我的扩展菜单',
    contexts: ['selection', 'link', 'image']
  });

  // 子菜单
  chrome.contextMenus.create({
    id: 'submenu1',
    parentId: 'myMenu',
    title: '操作1',
    contexts: ['selection']
  });

  chrome.contextMenus.create({
    id: 'submenu2',
    parentId: 'myMenu',
    title: '操作2',
    contexts: ['selection']
  });
});

// 监听菜单点击
chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === 'submenu1') {
    // 处理选中文本
    const selectedText = info.selectionText;
    console.log('选中的文本:', selectedText);

    // 发送消息到content script
    chrome.tabs.sendMessage(tab.id, {
      action: 'processText',
      text: selectedText
    });
  } else if (info.menuItemId === 'submenu2') {
    // 处理链接
    if (info.linkUrl) {
      console.log('链接URL:', info.linkUrl);
    }
  }
});
```

### 9. Omnibox (地址栏集成)
在地址栏中添加关键字触发扩展功能。

**manifest.json 配置:**
```json
{
  "omnibox": {
    "keyword": "ext"
  }
}
```

**background.js:**
```javascript
// 监听用户输入
chrome.omnibox.onInputStarted.addListener(() => {
  console.log('用户开始输入');
});

chrome.omnibox.onInputChanged.addListener((text, suggest) => {
  // 提供建议
  suggest([
    {
      content: `search ${text}`,
      description: `搜索: ${text}`
    },
    {
      content: `translate ${text}`,
      description: `翻译: ${text}`
    }
  ]);
});

chrome.omnibox.onInputEntered.addListener((text, disposition) => {
  if (text.startsWith('search ')) {
    const query = text.replace('search ', '');
    chrome.tabs.create({
      url: `https://www.google.com/search?q=${encodeURIComponent(query)}`
    });
  } else if (text.startsWith('translate ')) {
    const textToTranslate = text.replace('translate ', '');
    // 处理翻译逻辑
  }
});

chrome.omnibox.onInputCancelled.addListener(() => {
  console.log('用户取消输入');
});
```

### 10. Override Pages (覆盖页面)
覆盖浏览器默认页面。

**manifest.json 配置:**
```json
{
  "chrome_url_overrides": {
    "newtab": "newtab.html",
    "bookmarks": "bookmarks.html",
    "history": "history.html"
  }
}
```

**newtab.html (新标签页示例):**
```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="newtab.css">
</head>
<body>
  <div class="newtab-container">
    <div class="clock" id="clock">00:00:00</div>
    <div class="date" id="date"></div>
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="搜索或输入网址">
      <button id="searchBtn">搜索</button>
    </div>
    <div class="quick-links">
      <h3>快速链接</h3>
      <div class="links-grid" id="linksGrid"></div>
    </div>
  </div>
  <script src="newtab.js"></script>
</body>
</html>
```

**newtab.js:**
```javascript
// 更新时钟
function updateClock() {
  const now = new Date();
  const timeString = now.toLocaleTimeString('zh-CN');
  const dateString = now.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    weekday: 'long'
  });

  document.getElementById('clock').textContent = timeString;
  document.getElementById('date').textContent = dateString;
}

setInterval(updateClock, 1000);
updateClock();

// 搜索功能
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');

function performSearch() {
  const query = searchInput.value.trim();
  if (query) {
    // 检查是否为网址
    if (query.includes('.') && !query.includes(' ')) {
      chrome.tabs.create({ url: query.startsWith('http') ? query : `https://${query}` });
    } else {
      chrome.tabs.create({
        url: `https://www.google.com/search?q=${encodeURIComponent(query)}`
      });
    }
  }
}

searchBtn.addEventListener('click', performSearch);
searchInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    performSearch();
  }
});

// 加载快速链接
chrome.storage.local.get(['quickLinks'], (result) => {
  const links = result.quickLinks || [
    { title: 'Google', url: 'https://www.google.com' },
    { title: 'GitHub', url: 'https://github.com' },
    { title: 'Stack Overflow', url: 'https://stackoverflow.com' }
  ];

  const linksGrid = document.getElementById('linksGrid');
  links.forEach(link => {
    const linkDiv = document.createElement('div');
    linkDiv.className = 'quick-link';
    linkDiv.innerHTML = `
      <a href="${link.url}" class="link-item">
        <div class="link-title">${link.title}</div>
      </a>
    `;
    linksGrid.appendChild(linkDiv);
  });
});
```

---

## 核心 API

### 1. Storage API
```javascript
// 保存数据
chrome.storage.local.set({ key: 'value' }, () => {
  console.log('数据已保存');
});

// 读取数据
chrome.storage.local.get(['key'], (result) => {
  console.log(result.key);
});

// 同步存储（跨设备同步）
chrome.storage.sync.set({ preferences: 'dark' });

// 监听存储变化
chrome.storage.onChanged.addListener((changes, namespace) => {
  for (let key in changes) {
    console.log(`${key} 从 ${namespace} 变更为:`, changes[key].newValue);
  }
});

// 清除数据
chrome.storage.local.clear();
```

### 2. Tabs API
```javascript
// 查询标签页
chrome.tabs.query({ active: true }, (tabs) => {
  console.log(tabs[0].url);
});

// 创建新标签页
chrome.tabs.create({ url: 'https://example.com' });

// 更新标签页
chrome.tabs.update(tabId, { url: 'https://newurl.com' });

// 移除标签页
chrome.tabs.remove(tabId);

// 监听标签页事件
chrome.tabs.onActivated.addListener((activeInfo) => {
  console.log('标签页激活:', activeInfo.tabId);
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === 'complete') {
    console.log('页面加载完成');
  }
});
```

### 3. Runtime API
```javascript
// 发送消息
chrome.runtime.sendMessage({ action: 'getData' }, (response) => {
  console.log(response);
});

// 监听消息
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  sendResponse({ data: 'response' });
  return true; // 保持消息通道开启以支持异步响应
});

// 获取扩展信息
chrome.runtime.getURL('icons/icon.png');
console.log('扩展ID:', chrome.runtime.id);

// 获取后台页面
chrome.runtime.getBackgroundPage();
```

### 4. Messaging API
```javascript
// Content Script 发送消息到 Background
chrome.runtime.sendMessage({ type: 'PAGE_DATA', data: '...' });

// Background 发送消息到 Content Script
chrome.tabs.sendMessage(tabId, { action: 'updateContent' });

// Popup 发送消息到 Background
chrome.runtime.sendMessage({ action: 'getUserInfo' });

// 长连接
const port = chrome.runtime.connect({ name: 'my-connection' });
port.postMessage({ type: 'init' });
port.onMessage.addListener((msg) => {
  console.log('收到消息:', msg);
});

// 向其他扩展发送消息
chrome.runtime.sendMessage(otherExtensionId, { type: 'external' });

// 向原生应用发送消息
chrome.runtime.sendNativeMessage('com.example.native', { data: 'test' });
```

### 5. Alarms API
```javascript
// 创建定时器
chrome.alarms.create('myAlarm', {
  delayInMinutes: 10,
  periodInMinutes: 10
});

// 监听定时器
chrome.alarms.onAlarm.addListener((alarm) => {
  console.log('定时器触发:', alarm.name);
});

// 清除定时器
chrome.alarms.clear('myAlarm');
```

### 6. Notifications API
```javascript
// 创建通知
chrome.notifications.create({
  type: 'basic',
  iconUrl: 'icons/icon128.png',
  title: '通知标题',
  message: '通知内容',
  priority: 2
});

// 监听通知点击
chrome.notifications.onClicked.addListener((notificationId) => {
  console.log('通知被点击:', notificationId);
});
```

### 7. WebRequest API
```javascript
// 监听请求
chrome.webRequest.onBeforeRequest.addListener(
  (details) => {
    console.log('请求URL:', details.url);
    return { cancel: false };
  },
  { urls: ['<all_urls>'] },
  ['requestBody']
);

// 修改请求头
chrome.webRequest.onBeforeSendHeaders.addListener(
  (details) => {
    details.requestHeaders.push({
      name: 'Custom-Header',
      value: 'CustomValue'
    });
    return { requestHeaders: details.requestHeaders };
  },
  { urls: ['<all_urls>'] },
  ['blocking', 'requestHeaders']
);
```

---

## 权限系统

### 常见权限
```json
{
  "permissions": [
    "storage",       // 数据存储
    "tabs",          // 标签页访问
    "activeTab",     // 当前活动标签页
    "scripting",     // 脚本注入
    "notifications", // 系统通知
    "cookies",       // Cookie访问
    "webRequest",    // 网络请求拦截
    "alarms",        // 定时器
    "bookmarks",     // 书签访问
    "history",       // 历史记录访问
    "downloads",     // 下载管理
    "contextMenus",  // 右键菜单
    "sidePanel",     // 侧边栏
    "devtools",      // 开发者工具
    "geolocation",   // 地理位置
    "clipboardRead", // 剪贴板读取
    "clipboardWrite" // 剪贴板写入
  ],
  "host_permissions": [
    "https://*/*",   // 访问所有HTTPS网站
    "http://localhost/*"  // 访问本地服务器
  ]
}
```

### 权限最佳实践
1. **最小权限原则**: 只请求必要的权限
2. **activeTab**: 优先使用activeTab而不是tabs
3. **可选权限**: 考虑使用optional_permissions让用户选择

```json
{
  "permissions": ["activeTab"],
  "optional_permissions": ["tabs", "bookmarks"],
  "optional_host_permissions": ["https://*.google.com/*"]
}
```

---

## 开发工作流程

### 1. 项目结构
```
my-extension/
├── manifest.json           # 扩展配置文件
├── popup/
│   ├── popup.html         # 弹出界面结构
│   ├── popup.css          # 弹出界面样式
│   └── popup.js           # 弹出界面逻辑
├── background.js          # 后台脚本
├── content/
│   ├── content.js         # 内容脚本
│   └── content.css        # 内容脚本样式
├── sidepanel/
│   ├── sidepanel.html     # 侧边栏页面
│   ├── sidepanel.css      # 侧边栏样式
│   └── sidepanel.js       # 侧边栏逻辑
├── options/
│   ├── options.html       # 设置页面
│   ├── options.css        # 设置页面样式
│   └── options.js         # 设置页面逻辑
├── devtools/
│   ├── devtools.html      # 开发工具页面
│   ├── devtools.js        # 开发工具逻辑
│   ├── panel.html         # 自定义面板
│   ├── panel.css          # 面板样式
│   └── panel.js           # 面板逻辑
├── icons/
│   ├── icon16.png         # 16x16 图标
│   ├── icon48.png         # 48x48 图标
│   └── icon128.png        # 128x128 图标
└── _locales/
    ├── zh_CN/
    │   └── messages.json  # 中文翻译
    └── en/
        └── messages.json  # 英文翻译
```

### 2. 调试方法
1. 打开 Chrome 扩展管理页面 (`chrome://extensions/`)
2. 启用"开发者模式"
3. 点击"加载已解压的扩展程序"
4. 选择扩展文件夹
5. 修改代码后点击"重新加载"按钮

### 3. 查看日志
- **Background Script**: 在扩展管理页面点击"Service Worker"查看
- **Content Script**: 在对应网页的 DevTools Console 中查看
- **Popup**: 右键点击弹出界面选择"检查"
- **Side Panel**: 右键点击侧边栏选择"检查"
- **Options Page**: 正常使用F12开发者工具

### 4. 性能分析
- 使用Chrome DevTools的Performance面板分析性能
- 监控内存使用情况
- 检查CPU使用率

---

## 关键概念

### 1. 生命周期
- **Background**: 长期运行（Service Worker模式可能被挂起）
- **Content Script**: 页面加载时注入，页面关闭时销毁
- **Popup**: 打开时创建，关闭时销毁
- **Side Panel**: 在打开状态下持续运行
- **Options Page**: 打开时创建，关闭时销毁

### 2. 通信模式
```
┌─────────────┐
│   Popup     │
└──────┬──────┘
       │
       ▼
┌─────────────┐     messages     ┌──────────────┐
│  Background │◄────────────────►│Content Script│
└──────┬──────┘                  └──────────────┘
       │
       ▼
┌─────────────┐
│ Side Panel  │
└─────────────┘
```

- **Background ↔ Content**: 消息传递
- **Popup ↔ Background**: 消息传递
- **Popup ↔ Content**: 通过 Background 中转
- **Content ↔ Content**: 通过 Background 中转
- **Side Panel ↔ Background**: 消息传递

### 3. 安全性
- Content Script 无法访问扩展 API（部分）
- Background 无法直接访问页面 DOM
- 所有通信都是异步的
- 需要声明适当的权限
- 遵循同源策略
- 使用Content Security Policy (CSP)

### 4. 数据隔离
- **Storage**: 扩展专属存储，与网页隔离
- **IndexedDB**: 扩展专属数据库
- **Session Storage**: 仅在当前会话有效
- **Cookies**: 通过权限访问

---

## 学习路径建议

### 初级阶段
1. **基础**: 熟悉 HTML/CSS/JavaScript
2. **Manifest**: 学习 manifest.json 配置
3. **简单扩展**: 创建第一个扩展

### 中级阶段
1. **API 掌握**: 重点学习 Chrome Extension API
2. **通信机制**: 理解组件间通信
3. **存储管理**: 学会使用各种存储方式
4. **UI组件**: 掌握Popup、Options、Side Panel

### 高级阶段
1. **性能优化**: 优化扩展性能
2. **安全最佳实践**: 了解安全风险和防范
3. **跨浏览器兼容**: 适配不同浏览器
4. **高级功能**: Content Script注入、网络拦截等

### 发布流程
1. **测试**: 充分测试扩展功能
2. **打包**: 准备发布包
3. **审核**: 提交到 Chrome Web Store
4. **维护**: 持续更新和修复

---

## 参考资源

- [Chrome Extension 官方文档](https://developer.chrome.com/docs/extensions/)
- [MDN Web Extensions API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions)
- [Chrome Extension Samples](https://github.com/GoogleChrome/chrome-extensions-samples)
- [Extension Workshop (Firefox)](https://extensionworkshop.com/)

---

## 快速开始示例

### 最简单的扩展

**manifest.json:**
```json
{
  "manifest_version": 3,
  "name": "我的第一个扩展",
  "version": "1.0",
  "description": "Hello World",
  "action": {
    "default_popup": "popup.html"
  }
}
```

**popup.html:**
```html
<!DOCTYPE html>
<html>
<body>
  <h1>Hello, World!</h1>
  <script src="popup.js"></script>
</body>
</html>
```

**popup.js:**
```javascript
console.log('Popup 已加载');
alert('欢迎来到我的扩展！');
```

将这三个文件放在同一文件夹中，然后在 Chrome 扩展管理页面加载该文件夹，你的第一个扩展就完成了！

---

## 进阶示例

### 功能完整的扩展结构

这个示例展示了一个功能完整的扩展，包含所有主要组件：

1. **Popup**: 快速操作界面
2. **Side Panel**: 持久显示的信息面板
3. **Options**: 详细设置页面
4. **Content Script**: 页面内容增强
5. **Background**: 后台逻辑处理
6. **Context Menu**: 右键菜单集成

通过组合这些组件，你可以创建强大的浏览器扩展来增强用户的网页浏览体验。
